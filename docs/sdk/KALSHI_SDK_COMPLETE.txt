================================================================================
KALSHI SDK EXPLORATION
================================================================================
Generated: 2026-01-21 16:56:37

SDK Location: C:\Users\kbwil\Documents\Data_Projects\information_markets\information_markets\venv\Lib\site-packages\kalshi_python_sync\__init__.py
SDK Version: 3.2.0

================================================================================
MAIN MODULE EXPORTS
================================================================================

Exported items: 161
  AcceptQuoteRequest: class (ModelMetaclass)
  AmendOrderRequest: class (ModelMetaclass)
  AmendOrderResponse: class (ModelMetaclass)
  Announcement: class (ModelMetaclass)
  ApiAttributeError: class (type)
  ApiClient: class (type)
  ApiException: class (type)
  ApiKey: class (ModelMetaclass)
  ApiKeyError: class (type)
  ApiKeysApi: class (type)
  ApiResponse: class (ModelMetaclass)
  ApiTypeError: class (type)
  ApiValueError: class (type)
  AssociatedEvent: class (ModelMetaclass)
  BadRequestException: class (type)
  BatchCancelOrdersIndividualResponse: class (ModelMetaclass)
  BatchCancelOrdersRequest: class (ModelMetaclass)
  BatchCancelOrdersResponse: class (ModelMetaclass)
  BatchCreateOrdersIndividualResponse: class (ModelMetaclass)
  BatchCreateOrdersRequest: class (ModelMetaclass)
  BatchCreateOrdersResponse: class (ModelMetaclass)
  BatchGetMarketCandlesticksResponse: class (ModelMetaclass)
  BidAskDistribution: class (ModelMetaclass)
  CancelOrderResponse: class (ModelMetaclass)
  CommunicationsApi: class (type)
  Configuration: class (type)
  ConflictException: class (type)
  CreateApiKeyRequest: class (ModelMetaclass)
  CreateApiKeyResponse: class (ModelMetaclass)
  CreateMarketInMultivariateEventCollectionRequest: class (ModelMetaclass)
  CreateMarketInMultivariateEventCollectionResponse: class (ModelMetaclass)
  CreateOrderGroupRequest: class (ModelMetaclass)
  CreateOrderGroupResponse: class (ModelMetaclass)
  CreateOrderRequest: class (ModelMetaclass)
  CreateOrderResponse: class (ModelMetaclass)
  CreateQuoteRequest: class (ModelMetaclass)
  CreateQuoteResponse: class (ModelMetaclass)
  CreateRFQRequest: class (ModelMetaclass)
  CreateRFQResponse: class (ModelMetaclass)
  DailySchedule: class (ModelMetaclass)
  DecreaseOrderRequest: class (ModelMetaclass)
  DecreaseOrderResponse: class (ModelMetaclass)
  ErrorResponse: class (ModelMetaclass)
  EventData: class (ModelMetaclass)
  EventPosition: class (ModelMetaclass)
  EventsApi: class (type)
  ExchangeApi: class (type)
  ExchangeStatus: class (ModelMetaclass)
  FcmApi: class (type)
  Fill: class (ModelMetaclass)
  ForbiddenException: class (type)
  ForecastPercentilesPoint: class (ModelMetaclass)
  GenerateApiKeyRequest: class (ModelMetaclass)
  GenerateApiKeyResponse: class (ModelMetaclass)
  GetApiKeysResponse: class (ModelMetaclass)
  GetBalanceResponse: class (ModelMetaclass)
  GetCommunicationsIDResponse: class (ModelMetaclass)
  GetEventCandlesticksResponse: class (ModelMetaclass)
  GetEventForecastPercentilesHistoryResponse: class (ModelMetaclass)
  GetEventMetadataResponse: class (ModelMetaclass)
  GetEventResponse: class (ModelMetaclass)
  GetEventsResponse: class (ModelMetaclass)
  GetExchangeAnnouncementsResponse: class (ModelMetaclass)
  GetExchangeScheduleResponse: class (ModelMetaclass)
  GetFillsResponse: class (ModelMetaclass)
  GetFiltersBySportsResponse: class (ModelMetaclass)
  GetIncentiveProgramsResponse: class (ModelMetaclass)
  GetLiveDataResponse: class (ModelMetaclass)
  GetLiveDatasResponse: class (ModelMetaclass)
  GetMarketCandlesticksResponse: class (ModelMetaclass)
  GetMarketOrderbookResponse: class (ModelMetaclass)
  GetMarketResponse: class (ModelMetaclass)
  GetMarketsResponse: class (ModelMetaclass)
  GetMilestoneResponse: class (ModelMetaclass)
  GetMilestonesResponse: class (ModelMetaclass)
  GetMultivariateEventCollectionLookupHistoryResponse: class (ModelMetaclass)
  GetMultivariateEventCollectionResponse: class (ModelMetaclass)
  GetMultivariateEventCollectionsResponse: class (ModelMetaclass)
  GetMultivariateEventsResponse: class (ModelMetaclass)
  GetOrderGroupResponse: class (ModelMetaclass)
  GetOrderGroupsResponse: class (ModelMetaclass)
  GetOrderQueuePositionResponse: class (ModelMetaclass)
  GetOrderQueuePositionsResponse: class (ModelMetaclass)
  GetOrderResponse: class (ModelMetaclass)
  GetOrdersResponse: class (ModelMetaclass)
  GetPortfolioRestingOrderTotalValueResponse: class (ModelMetaclass)
  GetPositionsResponse: class (ModelMetaclass)
  GetQuoteResponse: class (ModelMetaclass)
  GetQuotesResponse: class (ModelMetaclass)
  GetRFQResponse: class (ModelMetaclass)
  GetRFQsResponse: class (ModelMetaclass)
  GetSeriesFeeChangesResponse: class (ModelMetaclass)
  GetSeriesListResponse: class (ModelMetaclass)
  GetSeriesResponse: class (ModelMetaclass)
  GetSettlementsResponse: class (ModelMetaclass)
  GetStructuredTargetResponse: class (ModelMetaclass)
  GetStructuredTargetsResponse: class (ModelMetaclass)
  GetTagsForSeriesCategoriesResponse: class (ModelMetaclass)
  GetTradesResponse: class (ModelMetaclass)
  GetUserDataTimestampResponse: class (ModelMetaclass)
  IncentiveProgram: class (ModelMetaclass)
  IncentiveProgramsApi: class (type)
  KalshiAuth: class (type)
  KalshiClient: class (type)
  LiveData: class (ModelMetaclass)
  LiveDataApi: class (type)
  LookupPoint: class (ModelMetaclass)
  LookupTickersForMarketInMultivariateEventCollectionRequest: class (ModelMetaclass)
  LookupTickersForMarketInMultivariateEventCollectionResponse: class (ModelMetaclass)
  MaintenanceWindow: class (ModelMetaclass)
  Market: class (ModelMetaclass)
  MarketApi: class (type)
  MarketCandlestick: class (ModelMetaclass)
  MarketCandlesticksResponse: class (ModelMetaclass)
  MarketMetadata: class (ModelMetaclass)
  MarketPosition: class (ModelMetaclass)
  Milestone: class (ModelMetaclass)
  MilestoneApi: class (type)
  MultivariateApi: class (type)
  MultivariateEventCollection: class (ModelMetaclass)
  MveSelectedLeg: class (ModelMetaclass)
  NotFoundException: class (type)
  OpenApiException: class (type)
  Order: class (ModelMetaclass)
  OrderGroup: class (ModelMetaclass)
  OrderGroupsApi: class (type)
  OrderQueuePosition: class (ModelMetaclass)
  OrderStatus: class (EnumType)
  Orderbook: class (ModelMetaclass)
  OrdersApi: class (type)
  PercentilePoint: class (ModelMetaclass)
  PortfolioApi: class (type)
  PriceDistribution: class (ModelMetaclass)
  PriceRange: class (ModelMetaclass)
  Quote: class (ModelMetaclass)
  RFQ: class (ModelMetaclass)
  Schedule: class (ModelMetaclass)
  ScopeList: class (ModelMetaclass)
  SearchApi: class (type)
  SelfTradePreventionType: class (EnumType)
  Series: class (ModelMetaclass)
  SeriesFeeChange: class (ModelMetaclass)
  ServiceException: class (type)
  Settlement: class (ModelMetaclass)
  SettlementSource: class (ModelMetaclass)
  SportFilterDetails: class (ModelMetaclass)
  StructuredTarget: class (ModelMetaclass)
  StructuredTargetsApi: class (type)
  TickerPair: class (ModelMetaclass)
  Trade: class (ModelMetaclass)
  UnauthorizedException: class (type)
  UnprocessableEntityException: class (type)
  WeeklySchedule: class (ModelMetaclass)
  api: module
  api_client: module
  api_response: module
  auth: module
  configuration: module
  exceptions: module
  models: module
  rest: module

================================================================================
KALSHI CLIENT CLASS
================================================================================

__init__ signature:
  (self, configuration=None)

Public methods: 16

  call_api(self, method, url, header_params=None, body=None, post_params=None, _request_timeout=None) -> kalshi_python_sync.rest.RESTResponse

  deserialize(self, response_text: str, response_type: str, content_type: Optional[str])

  files_parameters(self, files: Dict[str, Union[str, bytes, List[str], List[bytes], Tuple[str, bytes]]])

  get_default()

  param_serialize(self, method, resource_path, path_params=None, query_params=None, header_params=None, body=None, post_params=None, files=None, auth_settings=None, collection_formats=None, _host=None, _request_auth=None) -> Tuple[str, str, Dict[str, str], Optional[str], List[str]]

  parameters_to_tuples(self, params, collection_formats)

  parameters_to_url_query(self, params, collection_formats)

  response_deserialize(self, response_data: kalshi_python_sync.rest.RESTResponse, response_types_map: Optional[Dict[str, ~T]] = None) -> kalshi_python_sync.api_response.ApiResponse

  sanitize_for_serialization(self, obj)

  select_header_accept(self, accepts: List[str]) -> Optional[str]

  select_header_content_type(self, content_types)

  set_bearer_token(self, token: str)

  set_default(default)

  set_default_header(self, header_name, header_value)

  set_kalshi_auth(self, key_id: str, private_key_path: str)

  update_params_for_auth(self, headers, queries, auth_settings, resource_path, method, body, request_auth=None)

================================================================================
API SUBMODULES
================================================================================

Found 15 API modules:

  api_keys_api:
    Classes: Annotated, Any, ApiClient, ApiKeysApi, ApiResponse, CreateApiKeyRequest, CreateApiKeyResponse, GenerateApiKeyRequest, GenerateApiKeyResponse, GetApiKeysResponse, RESTResponseType
    Functions: Field, validate_call

  communications_api:
    Classes: AcceptQuoteRequest, Annotated, Any, ApiClient, ApiResponse, CommunicationsApi, CreateQuoteRequest, CreateQuoteResponse, CreateRFQRequest, CreateRFQResponse, GetCommunicationsIDResponse, GetQuoteResponse, GetQuotesResponse, GetRFQResponse, GetRFQsResponse, RESTResponseType
    Functions: Field, validate_call

  events_api:
    Classes: Annotated, Any, ApiClient, ApiResponse, EventsApi, GetEventCandlesticksResponse, GetEventForecastPercentilesHistoryResponse, GetEventMetadataResponse, GetEventResponse, GetEventsResponse, GetMultivariateEventsResponse, RESTResponseType
    Functions: Field, field_validator, validate_call

  exchange_api:
    Classes: Annotated, Any, ApiClient, ApiResponse, ExchangeApi, ExchangeStatus, GetExchangeAnnouncementsResponse, GetExchangeScheduleResponse, GetSeriesFeeChangesResponse, GetUserDataTimestampResponse, RESTResponseType
    Functions: Field, validate_call

  fcm_api:
    Classes: Annotated, Any, ApiClient, ApiResponse, FcmApi, GetOrdersResponse, GetPositionsResponse, RESTResponseType
    Functions: Field, field_validator, validate_call

  incentive_programs_api:
    Classes: Annotated, Any, ApiClient, ApiResponse, GetIncentiveProgramsResponse, IncentiveProgramsApi, RESTResponseType
    Functions: Field, field_validator, validate_call

  live_data_api:
    Classes: Annotated, Any, ApiClient, ApiResponse, GetLiveDataResponse, GetLiveDatasResponse, LiveDataApi, RESTResponseType
    Functions: Field, validate_call

  market_api:
    Classes: Annotated, Any, ApiClient, ApiResponse, BatchGetMarketCandlesticksResponse, GetMarketCandlesticksResponse, GetMarketOrderbookResponse, GetMarketResponse, GetMarketsResponse, GetSeriesListResponse, GetSeriesResponse, GetTradesResponse, MarketApi, RESTResponseType
    Functions: Field, field_validator, validate_call

  milestone_api:
    Classes: Annotated, Any, ApiClient, ApiResponse, GetMilestoneResponse, GetMilestonesResponse, MilestoneApi, RESTResponseType, datetime
    Functions: Field, validate_call

  multivariate_api:
    Classes: Annotated, Any, ApiClient, ApiResponse, CreateMarketInMultivariateEventCollectionRequest, CreateMarketInMultivariateEventCollectionResponse, GetMultivariateEventCollectionLookupHistoryResponse, GetMultivariateEventCollectionResponse, GetMultivariateEventCollectionsResponse, LookupTickersForMarketInMultivariateEventCollectionRequest, LookupTickersForMarketInMultivariateEventCollectionResponse, MultivariateApi, RESTResponseType
    Functions: Field, field_validator, validate_call

  order_groups_api:
    Classes: Annotated, Any, ApiClient, ApiResponse, CreateOrderGroupRequest, CreateOrderGroupResponse, GetOrderGroupResponse, GetOrderGroupsResponse, OrderGroupsApi, RESTResponseType
    Functions: Field, validate_call

  orders_api:
    Classes: AmendOrderRequest, AmendOrderResponse, Annotated, Any, ApiClient, ApiResponse, BatchCancelOrdersRequest, BatchCancelOrdersResponse, BatchCreateOrdersRequest, BatchCreateOrdersResponse, CancelOrderResponse, CreateOrderRequest, CreateOrderResponse, DecreaseOrderRequest, DecreaseOrderResponse, GetOrderQueuePositionResponse, GetOrderQueuePositionsResponse, GetOrderResponse, GetOrdersResponse, OrdersApi, RESTResponseType
    Functions: Field, validate_call

  portfolio_api:
    Classes: Annotated, Any, ApiClient, ApiResponse, GetBalanceResponse, GetFillsResponse, GetPortfolioRestingOrderTotalValueResponse, GetPositionsResponse, GetSettlementsResponse, PortfolioApi, RESTResponseType
    Functions: Field, validate_call

  search_api:
    Classes: Annotated, Any, ApiClient, ApiResponse, GetFiltersBySportsResponse, GetTagsForSeriesCategoriesResponse, RESTResponseType, SearchApi
    Functions: Field, validate_call

  structured_targets_api:
    Classes: Annotated, Any, ApiClient, ApiResponse, GetStructuredTargetResponse, GetStructuredTargetsResponse, RESTResponseType, StructuredTargetsApi
    Functions: Field, validate_call

================================================================================
MARKET API DETAILED EXPLORATION
================================================================================

MarketApi class methods:

  batch_get_market_candlesticks(self, market_tickers: Any, start_ts: Any, end_ts: Any, period_interval: Any, include_latest_before_start: Any = None) -> kalshi_python_sync.models.batch_get_market_candlesticks_response.BatchGetMarketCandlesticksResponse
    Batch Get Market Candlesticks

  batch_get_market_candlesticks_with_http_info(self, market_tickers: typing.Annotated[str, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, description='Comma-separated list of market tickers (maximum 100)')], start_ts: typing.Annotated[int, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, description='Start timestamp in Unix seconds')], end_ts: typing.Annotated[int, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, description='End timestamp in Unix seconds')], period_interval: typing.Annotated[int, FieldInfo(annotation=NoneType, required=True, description='Candlestick period interval in minutes', metadata=[Strict(strict=True), Ge(ge=1)])], include_latest_before_start: Annotated[Optional[Annotated[bool, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, description='If true, prepends the latest candlestick available before the start_ts. This synthetic candlestick is created by: 1. Finding the most recent real candlestick before start_ts 2. Projecting it forward to the first period boundary (calculated as the next period interval after start_ts) 3. Setting all OHLC prices to null, and `previous_price` to the close price from the real candlestick ')] = None, _request_timeout: Union[NoneType, Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])], Tuple[Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])], Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])]]] = None, _request_auth: Optional[Dict[Annotated[str, Strict(strict=True)], Any]] = None, _content_type: Optional[Annotated[str, Strict(strict=True)]] = None, _headers: Optional[Dict[Annotated[str, Strict(strict=True)], Any]] = None, _host_index: typing.Annotated[int, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Ge(ge=0), Le(le=0)])] = 0) -> kalshi_python_sync.api_response.ApiResponse[BatchGetMarketCandlesticksResponse]
    Batch Get Market Candlesticks

  batch_get_market_candlesticks_without_preload_content(self, market_tickers: typing.Annotated[str, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, description='Comma-separated list of market tickers (maximum 100)')], start_ts: typing.Annotated[int, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, description='Start timestamp in Unix seconds')], end_ts: typing.Annotated[int, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, description='End timestamp in Unix seconds')], period_interval: typing.Annotated[int, FieldInfo(annotation=NoneType, required=True, description='Candlestick period interval in minutes', metadata=[Strict(strict=True), Ge(ge=1)])], include_latest_before_start: Annotated[Optional[Annotated[bool, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, description='If true, prepends the latest candlestick available before the start_ts. This synthetic candlestick is created by: 1. Finding the most recent real candlestick before start_ts 2. Projecting it forward to the first period boundary (calculated as the next period interval after start_ts) 3. Setting all OHLC prices to null, and `previous_price` to the close price from the real candlestick ')] = None, _request_timeout: Union[NoneType, Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])], Tuple[Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])], Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])]]] = None, _request_auth: Optional[Dict[Annotated[str, Strict(strict=True)], Any]] = None, _content_type: Optional[Annotated[str, Strict(strict=True)]] = None, _headers: Optional[Dict[Annotated[str, Strict(strict=True)], Any]] = None, _host_index: typing.Annotated[int, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Ge(ge=0), Le(le=0)])] = 0) -> urllib3.response.HTTPResponse
    Batch Get Market Candlesticks

  get_market(self, ticker: typing.Annotated[str, Strict(strict=True)]) -> kalshi_python_sync.models.get_market_response.GetMarketResponse
    Get Market

  get_market_candlesticks(self, series_ticker: typing.Annotated[str, Strict(strict=True)], ticker: typing.Annotated[str, Strict(strict=True)], start_ts: Any, end_ts: Any, period_interval: Any) -> kalshi_python_sync.models.get_market_candlesticks_response.GetMarketCandlesticksResponse
    Get Market Candlesticks

  get_market_candlesticks_with_http_info(self, series_ticker: typing.Annotated[str, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, description='Series ticker - the series that contains the target market')], ticker: typing.Annotated[str, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, description='Market ticker - unique identifier for the specific market')], start_ts: typing.Annotated[int, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, description='Start timestamp (Unix timestamp). Candlesticks will include those ending on or after this time.')], end_ts: typing.Annotated[int, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, description='End timestamp (Unix timestamp). Candlesticks will include those ending on or before this time.')], period_interval: typing.Annotated[int, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, description='Time period length of each candlestick in minutes. Valid values are 1 (1 minute), 60 (1 hour), or 1440 (1 day).')], _request_timeout: Union[NoneType, Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])], Tuple[Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])], Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])]]] = None, _request_auth: Optional[Dict[Annotated[str, Strict(strict=True)], Any]] = None, _content_type: Optional[Annotated[str, Strict(strict=True)]] = None, _headers: Optional[Dict[Annotated[str, Strict(strict=True)], Any]] = None, _host_index: typing.Annotated[int, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Ge(ge=0), Le(le=0)])] = 0) -> kalshi_python_sync.api_response.ApiResponse[GetMarketCandlesticksResponse]
    Get Market Candlesticks

  get_market_candlesticks_without_preload_content(self, series_ticker: typing.Annotated[str, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, description='Series ticker - the series that contains the target market')], ticker: typing.Annotated[str, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, description='Market ticker - unique identifier for the specific market')], start_ts: typing.Annotated[int, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, description='Start timestamp (Unix timestamp). Candlesticks will include those ending on or after this time.')], end_ts: typing.Annotated[int, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, description='End timestamp (Unix timestamp). Candlesticks will include those ending on or before this time.')], period_interval: typing.Annotated[int, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, description='Time period length of each candlestick in minutes. Valid values are 1 (1 minute), 60 (1 hour), or 1440 (1 day).')], _request_timeout: Union[NoneType, Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])], Tuple[Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])], Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])]]] = None, _request_auth: Optional[Dict[Annotated[str, Strict(strict=True)], Any]] = None, _content_type: Optional[Annotated[str, Strict(strict=True)]] = None, _headers: Optional[Dict[Annotated[str, Strict(strict=True)], Any]] = None, _host_index: typing.Annotated[int, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Ge(ge=0), Le(le=0)])] = 0) -> urllib3.response.HTTPResponse
    Get Market Candlesticks

  get_market_orderbook(self, ticker: typing.Annotated[str, Strict(strict=True)], depth: Any = None) -> kalshi_python_sync.models.get_market_orderbook_response.GetMarketOrderbookResponse
    Get Market Orderbook

  get_market_orderbook_with_http_info(self, ticker: typing.Annotated[str, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, description='Market ticker')], depth: Annotated[Optional[Annotated[int, FieldInfo(annotation=NoneType, required=True, metadata=[Strict(strict=True), Ge(ge=0), Le(le=100)])]], FieldInfo(annotation=NoneType, required=True, description='Depth of the orderbook to retrieve (0 or negative means all levels, 1-100 for specific depth)')] = None, _request_timeout: Union[NoneType, Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])], Tuple[Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])], Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])]]] = None, _request_auth: Optional[Dict[Annotated[str, Strict(strict=True)], Any]] = None, _content_type: Optional[Annotated[str, Strict(strict=True)]] = None, _headers: Optional[Dict[Annotated[str, Strict(strict=True)], Any]] = None, _host_index: typing.Annotated[int, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Ge(ge=0), Le(le=0)])] = 0) -> kalshi_python_sync.api_response.ApiResponse[GetMarketOrderbookResponse]
    Get Market Orderbook

  get_market_orderbook_without_preload_content(self, ticker: typing.Annotated[str, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, description='Market ticker')], depth: Annotated[Optional[Annotated[int, FieldInfo(annotation=NoneType, required=True, metadata=[Strict(strict=True), Ge(ge=0), Le(le=100)])]], FieldInfo(annotation=NoneType, required=True, description='Depth of the orderbook to retrieve (0 or negative means all levels, 1-100 for specific depth)')] = None, _request_timeout: Union[NoneType, Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])], Tuple[Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])], Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])]]] = None, _request_auth: Optional[Dict[Annotated[str, Strict(strict=True)], Any]] = None, _content_type: Optional[Annotated[str, Strict(strict=True)]] = None, _headers: Optional[Dict[Annotated[str, Strict(strict=True)], Any]] = None, _host_index: typing.Annotated[int, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Ge(ge=0), Le(le=0)])] = 0) -> urllib3.response.HTTPResponse
    Get Market Orderbook

  get_market_with_http_info(self, ticker: typing.Annotated[str, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, description='Market ticker')], _request_timeout: Union[NoneType, Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])], Tuple[Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])], Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])]]] = None, _request_auth: Optional[Dict[Annotated[str, Strict(strict=True)], Any]] = None, _content_type: Optional[Annotated[str, Strict(strict=True)]] = None, _headers: Optional[Dict[Annotated[str, Strict(strict=True)], Any]] = None, _host_index: typing.Annotated[int, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Ge(ge=0), Le(le=0)])] = 0) -> kalshi_python_sync.api_response.ApiResponse[GetMarketResponse]
    Get Market

  get_market_without_preload_content(self, ticker: typing.Annotated[str, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, description='Market ticker')], _request_timeout: Union[NoneType, Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])], Tuple[Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])], Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])]]] = None, _request_auth: Optional[Dict[Annotated[str, Strict(strict=True)], Any]] = None, _content_type: Optional[Annotated[str, Strict(strict=True)]] = None, _headers: Optional[Dict[Annotated[str, Strict(strict=True)], Any]] = None, _host_index: typing.Annotated[int, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Ge(ge=0), Le(le=0)])] = 0) -> urllib3.response.HTTPResponse
    Get Market

  get_markets(self, limit: Any = None, cursor: Any = None, event_ticker: Any = None, series_ticker: Any = None, min_created_ts: Any = None, max_created_ts: Any = None, max_close_ts: Any = None, min_close_ts: Any = None, min_settled_ts: Any = None, max_settled_ts: Any = None, status: Any = None, tickers: Any = None, mve_filter: Any = None) -> kalshi_python_sync.models.get_markets_response.GetMarketsResponse
    Get Markets

  get_markets_with_http_info(self, limit: Annotated[Optional[Annotated[int, FieldInfo(annotation=NoneType, required=True, metadata=[Strict(strict=True), Ge(ge=1), Le(le=1000)])]], FieldInfo(annotation=NoneType, required=True, description='Number of results per page. Defaults to 100. Maximum value is 1000.')] = None, cursor: Annotated[Optional[Annotated[str, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, description='Pagination cursor. Use the cursor value returned from the previous response to get the next page of results. Leave empty for the first page.')] = None, event_ticker: Annotated[Optional[Annotated[str, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, description='Event ticker of desired positions. Multiple event tickers can be provided as a comma-separated list (maximum 10).')] = None, series_ticker: Annotated[Optional[Annotated[str, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, description='Filter by series ticker')] = None, min_created_ts: Annotated[Optional[Annotated[int, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, description='Filter items that created after this Unix timestamp')] = None, max_created_ts: Annotated[Optional[Annotated[int, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, description='Filter items that created before this Unix timestamp')] = None, max_close_ts: Annotated[Optional[Annotated[int, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, description='Filter items that close before this Unix timestamp')] = None, min_close_ts: Annotated[Optional[Annotated[int, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, description='Filter items that close after this Unix timestamp')] = None, min_settled_ts: Annotated[Optional[Annotated[int, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, description='Filter items that settled after this Unix timestamp')] = None, max_settled_ts: Annotated[Optional[Annotated[int, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, description='Filter items that settled before this Unix timestamp')] = None, status: Annotated[Optional[Annotated[str, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, description="Filter by market status. Possible values are 'unopened', 'open', 'closed', 'settled'. Leave empty to return markets with any status.")] = None, tickers: Annotated[Optional[Annotated[str, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, description='Filter by specific market tickers. Comma-separated list of market tickers to retrieve.')] = None, mve_filter: Annotated[Optional[Annotated[str, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, description="Filter by multivariate events (combos). 'only' returns only multivariate events, 'exclude' excludes multivariate events.")] = None, _request_timeout: Union[NoneType, Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])], Tuple[Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])], Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])]]] = None, _request_auth: Optional[Dict[Annotated[str, Strict(strict=True)], Any]] = None, _content_type: Optional[Annotated[str, Strict(strict=True)]] = None, _headers: Optional[Dict[Annotated[str, Strict(strict=True)], Any]] = None, _host_index: typing.Annotated[int, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Ge(ge=0), Le(le=0)])] = 0) -> kalshi_python_sync.api_response.ApiResponse[GetMarketsResponse]
    Get Markets

  get_markets_without_preload_content(self, limit: Annotated[Optional[Annotated[int, FieldInfo(annotation=NoneType, required=True, metadata=[Strict(strict=True), Ge(ge=1), Le(le=1000)])]], FieldInfo(annotation=NoneType, required=True, description='Number of results per page. Defaults to 100. Maximum value is 1000.')] = None, cursor: Annotated[Optional[Annotated[str, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, description='Pagination cursor. Use the cursor value returned from the previous response to get the next page of results. Leave empty for the first page.')] = None, event_ticker: Annotated[Optional[Annotated[str, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, description='Event ticker of desired positions. Multiple event tickers can be provided as a comma-separated list (maximum 10).')] = None, series_ticker: Annotated[Optional[Annotated[str, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, description='Filter by series ticker')] = None, min_created_ts: Annotated[Optional[Annotated[int, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, description='Filter items that created after this Unix timestamp')] = None, max_created_ts: Annotated[Optional[Annotated[int, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, description='Filter items that created before this Unix timestamp')] = None, max_close_ts: Annotated[Optional[Annotated[int, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, description='Filter items that close before this Unix timestamp')] = None, min_close_ts: Annotated[Optional[Annotated[int, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, description='Filter items that close after this Unix timestamp')] = None, min_settled_ts: Annotated[Optional[Annotated[int, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, description='Filter items that settled after this Unix timestamp')] = None, max_settled_ts: Annotated[Optional[Annotated[int, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, description='Filter items that settled before this Unix timestamp')] = None, status: Annotated[Optional[Annotated[str, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, description="Filter by market status. Possible values are 'unopened', 'open', 'closed', 'settled'. Leave empty to return markets with any status.")] = None, tickers: Annotated[Optional[Annotated[str, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, description='Filter by specific market tickers. Comma-separated list of market tickers to retrieve.')] = None, mve_filter: Annotated[Optional[Annotated[str, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, description="Filter by multivariate events (combos). 'only' returns only multivariate events, 'exclude' excludes multivariate events.")] = None, _request_timeout: Union[NoneType, Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])], Tuple[Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])], Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])]]] = None, _request_auth: Optional[Dict[Annotated[str, Strict(strict=True)], Any]] = None, _content_type: Optional[Annotated[str, Strict(strict=True)]] = None, _headers: Optional[Dict[Annotated[str, Strict(strict=True)], Any]] = None, _host_index: typing.Annotated[int, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Ge(ge=0), Le(le=0)])] = 0) -> urllib3.response.HTTPResponse
    Get Markets

  get_series(self, series_ticker: typing.Annotated[str, Strict(strict=True)]) -> kalshi_python_sync.models.get_series_response.GetSeriesResponse
    Get Series

  get_series_list(self, category: Any = None, tags: Any = None, include_product_metadata: Any = None) -> kalshi_python_sync.models.get_series_list_response.GetSeriesListResponse
    Get Series List

  get_series_list_with_http_info(self, category: Optional[Annotated[str, Strict(strict=True)]] = None, tags: Optional[Annotated[str, Strict(strict=True)]] = None, include_product_metadata: Optional[Annotated[bool, Strict(strict=True)]] = None, _request_timeout: Union[NoneType, Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])], Tuple[Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])], Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])]]] = None, _request_auth: Optional[Dict[Annotated[str, Strict(strict=True)], Any]] = None, _content_type: Optional[Annotated[str, Strict(strict=True)]] = None, _headers: Optional[Dict[Annotated[str, Strict(strict=True)], Any]] = None, _host_index: typing.Annotated[int, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Ge(ge=0), Le(le=0)])] = 0) -> kalshi_python_sync.api_response.ApiResponse[GetSeriesListResponse]
    Get Series List

  get_series_list_without_preload_content(self, category: Optional[Annotated[str, Strict(strict=True)]] = None, tags: Optional[Annotated[str, Strict(strict=True)]] = None, include_product_metadata: Optional[Annotated[bool, Strict(strict=True)]] = None, _request_timeout: Union[NoneType, Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])], Tuple[Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])], Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])]]] = None, _request_auth: Optional[Dict[Annotated[str, Strict(strict=True)], Any]] = None, _content_type: Optional[Annotated[str, Strict(strict=True)]] = None, _headers: Optional[Dict[Annotated[str, Strict(strict=True)], Any]] = None, _host_index: typing.Annotated[int, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Ge(ge=0), Le(le=0)])] = 0) -> urllib3.response.HTTPResponse
    Get Series List

  get_series_with_http_info(self, series_ticker: typing.Annotated[str, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, description='The ticker of the series to retrieve')], _request_timeout: Union[NoneType, Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])], Tuple[Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])], Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])]]] = None, _request_auth: Optional[Dict[Annotated[str, Strict(strict=True)], Any]] = None, _content_type: Optional[Annotated[str, Strict(strict=True)]] = None, _headers: Optional[Dict[Annotated[str, Strict(strict=True)], Any]] = None, _host_index: typing.Annotated[int, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Ge(ge=0), Le(le=0)])] = 0) -> kalshi_python_sync.api_response.ApiResponse[GetSeriesResponse]
    Get Series

  get_series_without_preload_content(self, series_ticker: typing.Annotated[str, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, description='The ticker of the series to retrieve')], _request_timeout: Union[NoneType, Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])], Tuple[Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])], Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])]]] = None, _request_auth: Optional[Dict[Annotated[str, Strict(strict=True)], Any]] = None, _content_type: Optional[Annotated[str, Strict(strict=True)]] = None, _headers: Optional[Dict[Annotated[str, Strict(strict=True)], Any]] = None, _host_index: typing.Annotated[int, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Ge(ge=0), Le(le=0)])] = 0) -> urllib3.response.HTTPResponse
    Get Series

  get_trades(self, limit: Any = None, cursor: Any = None, ticker: Any = None, min_ts: Any = None, max_ts: Any = None) -> kalshi_python_sync.models.get_trades_response.GetTradesResponse
    Get Trades

  get_trades_with_http_info(self, limit: Annotated[Optional[Annotated[int, FieldInfo(annotation=NoneType, required=True, metadata=[Strict(strict=True), Ge(ge=1), Le(le=1000)])]], FieldInfo(annotation=NoneType, required=True, description='Number of results per page. Defaults to 100. Maximum value is 1000.')] = None, cursor: Annotated[Optional[Annotated[str, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, description='Pagination cursor. Use the cursor value returned from the previous response to get the next page of results. Leave empty for the first page.')] = None, ticker: Annotated[Optional[Annotated[str, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, description='Filter by market ticker')] = None, min_ts: Annotated[Optional[Annotated[int, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, description='Filter items after this Unix timestamp')] = None, max_ts: Annotated[Optional[Annotated[int, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, description='Filter items before this Unix timestamp')] = None, _request_timeout: Union[NoneType, Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])], Tuple[Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])], Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])]]] = None, _request_auth: Optional[Dict[Annotated[str, Strict(strict=True)], Any]] = None, _content_type: Optional[Annotated[str, Strict(strict=True)]] = None, _headers: Optional[Dict[Annotated[str, Strict(strict=True)], Any]] = None, _host_index: typing.Annotated[int, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Ge(ge=0), Le(le=0)])] = 0) -> kalshi_python_sync.api_response.ApiResponse[GetTradesResponse]
    Get Trades

  get_trades_without_preload_content(self, limit: Annotated[Optional[Annotated[int, FieldInfo(annotation=NoneType, required=True, metadata=[Strict(strict=True), Ge(ge=1), Le(le=1000)])]], FieldInfo(annotation=NoneType, required=True, description='Number of results per page. Defaults to 100. Maximum value is 1000.')] = None, cursor: Annotated[Optional[Annotated[str, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, description='Pagination cursor. Use the cursor value returned from the previous response to get the next page of results. Leave empty for the first page.')] = None, ticker: Annotated[Optional[Annotated[str, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, description='Filter by market ticker')] = None, min_ts: Annotated[Optional[Annotated[int, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, description='Filter items after this Unix timestamp')] = None, max_ts: Annotated[Optional[Annotated[int, Strict(strict=True)]], FieldInfo(annotation=NoneType, required=True, description='Filter items before this Unix timestamp')] = None, _request_timeout: Union[NoneType, Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])], Tuple[Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])], Annotated[float, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Gt(gt=0)])]]] = None, _request_auth: Optional[Dict[Annotated[str, Strict(strict=True)], Any]] = None, _content_type: Optional[Annotated[str, Strict(strict=True)]] = None, _headers: Optional[Dict[Annotated[str, Strict(strict=True)], Any]] = None, _host_index: typing.Annotated[int, Strict(strict=True), FieldInfo(annotation=NoneType, required=True, metadata=[Ge(ge=0), Le(le=0)])] = 0) -> urllib3.response.HTTPResponse
    Get Trades

================================================================================
CONFIGURATION CLASS
================================================================================

Configuration attributes: 4
  debug: property = <property object at 0x000001EEE0F5BBA0>
  host: property = <property object at 0x000001EEE0F5BCE0>
  logger_file: property = <property object at 0x000001EEE0F5BB00>
  logger_format: property = <property object at 0x000001EEE0F5BC40>

================================================================================
MODELS/SCHEMAS
================================================================================

Found 120 model classes:
  AcceptQuoteRequest
  AmendOrderRequest
  AmendOrderResponse
  Announcement
  ApiKey
  AssociatedEvent
  BatchCancelOrdersIndividualResponse
  BatchCancelOrdersRequest
  BatchCancelOrdersResponse
  BatchCreateOrdersIndividualResponse
  BatchCreateOrdersRequest
  BatchCreateOrdersResponse
  BatchGetMarketCandlesticksResponse
  BidAskDistribution
  CancelOrderResponse
  CreateApiKeyRequest
  CreateApiKeyResponse
  CreateMarketInMultivariateEventCollectionRequest
  CreateMarketInMultivariateEventCollectionResponse
  CreateOrderGroupRequest
  CreateOrderGroupResponse
  CreateOrderRequest
  CreateOrderResponse
  CreateQuoteRequest
  CreateQuoteResponse
  CreateRFQRequest
  CreateRFQResponse
  DailySchedule
  DecreaseOrderRequest
  DecreaseOrderResponse
  ... and 90 more

================================================================================
SUMMARY
================================================================================

To use the Kalshi SDK:

1. Initialize client:
   from kalshi_python_sync import Configuration, KalshiClient
   
   config = Configuration(host="https://api.elections.kalshi.com/trade-api/v2")
   config.api_key_id = "your-api-key"
   config.private_key_pem = "your-private-key"
   
   client = KalshiClient(config)

2. Access API modules:
   - client.market_api - Market operations
   - client.portfolio_api - Portfolio operations
   - client.exchange_api - Exchange operations
   (Check the API submodules section above for available methods)

3. Models are in kalshi_python_sync.models
   (See Models section above for available classes)



Output saved to: C:\Users\kbwil\Documents\Data_Projects\information_markets\information_markets\docs\sdk\KALSHI_SDK_COMPLETE.txt