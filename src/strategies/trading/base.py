"""
Base class for all trading strategies.

All strategies follow the same pattern:
1. Analyze data from cache (instant, no API calls)
2. Generate signals
3. Execute trades (via API) only when signal is strong enough
"""
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any
from datetime import datetime
from enum import Enum
import json
from pathlib import Path

from src.core.data_manager import DataManager
from src.config import Config


class SignalType(Enum):
    """Type of trading signal."""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"


class SignalStrength(Enum):
    """Strength of trading signal."""
    STRONG = "strong"      # High confidence, larger position
    MODERATE = "moderate"  # Medium confidence, normal position
    WEAK = "weak"          # Low confidence, smaller position


@dataclass
class Signal:
    """A trading signal generated by a strategy."""
    strategy_name: str
    signal_type: SignalType
    strength: SignalStrength
    platform: str
    market_id: str
    market_title: str
    side: str  # 'yes' or 'no'
    target_price: float
    current_price: float
    confidence: float  # 0-1
    reasoning: str
    metadata: Dict = field(default_factory=dict)
    timestamp: datetime = field(default_factory=datetime.now)
    
    def to_dict(self) -> Dict:
        return {
            'strategy_name': self.strategy_name,
            'signal_type': self.signal_type.value,
            'strength': self.strength.value,
            'platform': self.platform,
            'market_id': self.market_id,
            'market_title': self.market_title,
            'side': self.side,
            'target_price': self.target_price,
            'current_price': self.current_price,
            'confidence': self.confidence,
            'reasoning': self.reasoning,
            'metadata': self.metadata,
            'timestamp': self.timestamp.isoformat()
        }


@dataclass
class Trade:
    """A trade to execute."""
    signal: Signal
    platform: str
    market_id: str
    side: str
    action: str  # 'buy' or 'sell'
    quantity: int
    price: Optional[float]  # None for market orders
    order_type: str = "limit"  # 'limit' or 'market'
    
    def to_dict(self) -> Dict:
        return {
            'platform': self.platform,
            'market_id': self.market_id,
            'side': self.side,
            'action': self.action,
            'quantity': self.quantity,
            'price': self.price,
            'order_type': self.order_type,
            'signal': self.signal.to_dict()
        }


@dataclass
class TradeResult:
    """Result of a trade execution."""
    trade: Trade
    success: bool
    order_id: Optional[str] = None
    filled_price: Optional[float] = None
    filled_quantity: Optional[int] = None
    error: Optional[str] = None
    timestamp: datetime = field(default_factory=datetime.now)
    
    def to_dict(self) -> Dict:
        return {
            'trade': self.trade.to_dict(),
            'success': self.success,
            'order_id': self.order_id,
            'filled_price': self.filled_price,
            'filled_quantity': self.filled_quantity,
            'error': self.error,
            'timestamp': self.timestamp.isoformat()
        }


class BaseStrategy(ABC):
    """
    Base class for all trading strategies.
    
    Strategies should:
    1. Read from DataManager (cached data only)
    2. Generate signals based on analysis
    3. NOT make API calls during analysis
    4. Only make API calls during trade execution
    """
    
    def __init__(self, data_manager: DataManager,
                 paper_trading: bool = True,
                 max_position_size: float = None):
        self.data_manager = data_manager
        self.paper_trading = paper_trading
        self.max_position_size = max_position_size or Config.MAX_POSITION_SIZE
        
        # Track performance
        self.signals_generated: List[Signal] = []
        self.trades_executed: List[TradeResult] = []
        
        # Paper trading log
        self.paper_trades_path = Path("data/paper_trades")
        self.paper_trades_path.mkdir(parents=True, exist_ok=True)
    
    @property
    @abstractmethod
    def name(self) -> str:
        """Strategy name."""
        pass
    
    @property
    @abstractmethod
    def description(self) -> str:
        """Strategy description."""
        pass
    
    @abstractmethod
    def analyze(self) -> List[Signal]:
        """
        Analyze market data and generate signals.
        
        This should ONLY read from DataManager (cached data).
        NEVER make API calls here.
        """
        pass
    
    def generate_trade(self, signal: Signal) -> Optional[Trade]:
        """Convert a signal into a trade."""
        if signal.signal_type == SignalType.HOLD:
            return None
        
        # Calculate position size based on confidence and strength
        base_size = self.max_position_size
        
        if signal.strength == SignalStrength.STRONG:
            size_multiplier = 1.0
        elif signal.strength == SignalStrength.MODERATE:
            size_multiplier = 0.6
        else:
            size_multiplier = 0.3
        
        quantity = int(base_size * size_multiplier * signal.confidence)
        
        if quantity < 1:
            return None
        
        # Determine action
        action = "buy" if signal.signal_type == SignalType.BUY else "sell"
        
        return Trade(
            signal=signal,
            platform=signal.platform,
            market_id=signal.market_id,
            side=signal.side,
            action=action,
            quantity=quantity,
            price=signal.target_price,
            order_type="limit"
        )
    
    def execute_trade(self, trade: Trade) -> TradeResult:
        """Execute a trade (real or paper)."""
        if self.paper_trading:
            return self._paper_trade(trade)
        else:
            return self._real_trade(trade)
    
    def _paper_trade(self, trade: Trade) -> TradeResult:
        """Simulate a trade in paper trading mode."""
        # Simulate execution at target price
        result = TradeResult(
            trade=trade,
            success=True,
            order_id=f"PAPER-{datetime.now().strftime('%Y%m%d%H%M%S%f')}",
            filled_price=trade.price or trade.signal.current_price,
            filled_quantity=trade.quantity
        )
        
        # Log the paper trade
        self._log_paper_trade(result)
        
        return result
    
    def _real_trade(self, trade: Trade) -> TradeResult:
        """Execute a real trade via API."""
        try:
            if trade.platform == 'kalshi':
                response = self.data_manager.kalshi.place_order(
                    ticker=trade.market_id,
                    side=trade.side,
                    action=trade.action,
                    count=trade.quantity,
                    price=int(trade.price * 100) if trade.price else None
                )
            else:  # polymarket
                response = self.data_manager.polymarket.place_order(
                    market_id=trade.market_id,
                    side=trade.side.upper(),
                    size=trade.quantity,
                    price=trade.price,
                    order_type=trade.order_type.upper()
                )
            
            return TradeResult(
                trade=trade,
                success=True,
                order_id=response.get('order_id') or response.get('id'),
                filled_price=response.get('price'),
                filled_quantity=response.get('filled_count') or response.get('filled')
            )
        except Exception as e:
            return TradeResult(
                trade=trade,
                success=False,
                error=str(e)
            )
    
    def _log_paper_trade(self, result: TradeResult):
        """Log paper trade to file."""
        log_file = self.paper_trades_path / f"{self.name}_{datetime.now().strftime('%Y%m%d')}.jsonl"
        
        with open(log_file, 'a') as f:
            f.write(json.dumps(result.to_dict()) + '\n')
    
    def run_once(self) -> List[TradeResult]:
        """Run strategy once: analyze and execute trades."""
        # Analyze (reads from cache only)
        signals = self.analyze()
        self.signals_generated.extend(signals)
        
        results = []
        for signal in signals:
            if signal.signal_type == SignalType.HOLD:
                continue
            
            trade = self.generate_trade(signal)
            if trade:
                result = self.execute_trade(trade)
                results.append(result)
                self.trades_executed.append(result)
        
        return results
    
    def get_performance_stats(self) -> Dict:
        """Get strategy performance statistics."""
        total_trades = len(self.trades_executed)
        successful = sum(1 for t in self.trades_executed if t.success)
        
        # Calculate P&L for paper trades
        paper_pnl = 0.0
        for result in self.trades_executed:
            if result.success and result.filled_price:
                # This is simplified - real P&L needs position tracking
                if result.trade.action == 'buy':
                    paper_pnl -= result.filled_price * result.filled_quantity
                else:
                    paper_pnl += result.filled_price * result.filled_quantity
        
        return {
            'strategy': self.name,
            'total_signals': len(self.signals_generated),
            'total_trades': total_trades,
            'successful_trades': successful,
            'failed_trades': total_trades - successful,
            'success_rate': successful / total_trades if total_trades > 0 else 0,
            'paper_pnl': paper_pnl,
            'paper_trading': self.paper_trading
        }

